Golang에는 아래 항목이 없다.

- 메모리 관리: 가비지 컬렉터가 메모리를 관리한다.
- Class: 객체지향 개념이 없다
- Try-Catch-Finally
- While, Do-While
- 동적 타입으로 인한 고통

고 언어는 태생부터 언어의 미니멀리즘을 추구했다. 그 흔한 객체지향 개념도 도입하지 않았고 고 언어에서 복잡한 문법은 오직 구조체 뿐이다. 그리고 또한 고 언어에는 쓰레드를 수동으로 생성하고 제어하는 방법이 없다. go 키워드를 이용한 고루틴 생성 로직만 존재한다. 쓰레드가 동시성을 다루는데 가장 기본이 되는 모듈인 것을 감안하면 파격적이다.

언어가 이렇게 발전된 계기에는 쓰레드가 문제였다는 인식이 배경이 된다. Goroutine, Coroutine, Fiber, Akka와 같은 경량 쓰레드(Micro-Thread, Light-weight Thread) 동시성 모델들과 Node.js와 같은 Event-Driven 모델이 탄생하고 주목받은 배경을 공통적으로 추려보면 쓰레드가 오늘날의 서버가 요구하는 스펙과는 맞지 않았기 때문이다.

현대 서버 프로그래밍의 발전 과정을 보면 서버의 성능이 낮은 이유를 대부분 CPU/GPU 같은 연산 하드웨어 스펙이 아닌 I/O Time에서 찾을 수 있다. I/O Time란 외부 리소스에서 결과를 받아오기까지의 시간을 말하며 쓰레드는 이 시간 동안 대기 상태에 빠져있다.

I/O 종류에는 파일 입출력을 위한 시스템 콜부터 다른 서버로부터 결과를 얻기 위한 통신 비용, 데이터베이스가 메모리에서 하드웨어로 데이터를 적재하는 비용, 데이터가 여러 데이터베이스에 존재하면 2PC 분산 트랜잭션을 처리하는 비용이 I/O Time에 해당한다. 이 I/O가 발생하는 동안에는 Thread는 결과를 받기까지 대기 상태에 들어가게 된다.

현재 서버 시스템에서 대부분의 병목은 연산 시간보다 I/O Time이 너무 길고 자주 발생하기 때문에 발생한다. 즉, 이 병목을 해결하는 방법은 프로세스 혹은 쓰레드를 대기 상태로 두지 않고 계속 일을 시키는 방법인데 대표적으로 Node.js에 적용된 이벤트 루프와 고 언어의 고루틴이 있다. 근데 여기서 우리는 한 가지 궁금증이 생긴다. 아니 원래 쓰레드가 컨텍스트-스위칭 하면서 작업을 번갈아 가면서 하는건데 그게 병목이 걸리는 게 큰 문제인가? 사실 스레드는 상당히 비싼 자원이다.

- Thread는 보통 256KB ~ 2MB 사이의 스택 크기를 가진다. 전통적인 서버 구성에서는 유저 당 쓰레드 하나에 할당하는게 일반적이었는데 Thread의 스택 사이즈를 1MB라고 한다면 4GB 메모리를 가진 서버에서는 4096개의 쓰레드만을 동시에 생성해서 사용할 수 있다.

- 컨텍스트 스위칭이란 하나의 작업 상태를 저장하고 다른 작업으로 전환하여 수행하는 것을 말한다. 프로세스를 스위칭 할 때는 메모리 상태를 직접 PCB에 저장했어야 해서 비용이 굉장히 비싸므로 이를 해결하기 위해서 공유 메모리를 사용한다는 개념이었다. 그래서 쓰레드를 스위칭하는게 프로세스를 스위칭하는 것보다 저렴한 것은 사실이지만 쓰레드도 각종 레지스터 정보들은 전부 저장해야 한다.

- 쓰레드를 생성하는 것도 비용이 많이 생성된다. 생성은 시스템 콜(System call)을 요구하는데 이 때 OS 레벨에서 컨텍스트 스위칭이 발생하고 OS로부터 사용 가능한 메모리 영역대를 할당 받게 되서 레이턴시가 높아 효율적이지 않다.

### 고루틴 !

> Goruntine은 Go runtime 환경에서 동작하는 쓰레드보다 굉장히 가벼운 실행 조각이다. 초기에 생성할 때 2KB의 매우 작은 스택 크기만을 필요로 하며 가지고 있는 레지스터도 프로그램 카운터 (PC)와 스택 포인터 (SP) 정도가 전부이다. 고루틴은 함수 단위로 실행할 수 있으며 함수 실행 앞에 go라는 키워드를 붙여서 생성한다.

```go
go func() {
  // Do some work.
}();
```

원래 Go runtime은 Go 1.14 이전 버전에는 C언어로 작성되어 있었다. Go 1.14 부터 runtime을 Go 언어로 작성하게 되면서 코어 코드 해석이 한결 편해졌다. 아래에는 고루틴의 구조체와 스케쥴러가 고루틴을 실행할 때 다루는 구조체인 gobuf가 정의되어 있다.

```go
type g struct {
  stack stack
  stackguard0 uintptr
  stackguard1 uintptr

  m *m // m (고루틴이 실행될 쓰레드)
  sched gobuf
  ...
}

type gobuf struct {
  sp uintptr // 스택 포인터
  pc uintptr // 프로그램 카운터
  g uintptr // 고루틴 포인터
  ctxt  unsafe.Pointer
  ret uintptr // 리턴 포인터
  lr uintptr // 리턴 레지스터 (고루틴 종료 후 돌아갈 장소)
  bp uintptr
}
```
