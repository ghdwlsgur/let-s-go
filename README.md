Golang에는 아래 항목이 없다.

> - `메모리 관리`: 가비지 컬렉터가 메모리를 관리한다.
> - `Class`: 객체지향 개념이 없다
> - `Try-Catch-Finally`
> - `While`, `Do-While`
> - `동적 타입으로 인한 고통`

고 언어는 태생부터 언어의 미니멀리즘을 추구했다. 그 흔한 객체지향 개념도 도입하지 않았고 고 언어에서 복잡한 문법은 오직 구조체 뿐이다. 그리고 또한 고 언어에는 쓰레드를 수동으로 생성하고 제어하는 방법이 없다. go 키워드를 이용한 고루틴 생성 로직만 존재한다. 쓰레드가 동시성을 다루는데 가장 기본이 되는 모듈인 것을 감안하면 파격적이다.

언어가 이렇게 발전된 계기에는 쓰레드가 문제였다는 인식이 배경이 된다. Goroutine, Coroutine, Fiber, Akka와 같은 경량 쓰레드(Micro-Thread, Light-weight Thread) 동시성 모델들과 Node.js와 같은 Event-Driven 모델이 탄생하고 주목받은 배경을 공통적으로 추려보면 쓰레드가 오늘날의 서버가 요구하는 스펙과는 맞지 않았기 때문이다.

현대 서버 프로그래밍의 발전 과정을 보면 서버의 성능이 낮은 이유를 대부분 CPU/GPU 같은 연산 하드웨어 스펙이 아닌 I/O Time에서 찾을 수 있다. I/O Time란 외부 리소스에서 결과를 받아오기까지의 시간을 말하며 쓰레드는 이 시간 동안 대기 상태에 빠져있다.

I/O 종류에는 파일 입출력을 위한 시스템 콜부터 다른 서버로부터 결과를 얻기 위한 통신 비용, 데이터베이스가 메모리에서 하드웨어로 데이터를 적재하는 비용, 데이터가 여러 데이터베이스에 존재하면 2PC 분산 트랜잭션을 처리하는 비용이 I/O Time에 해당한다. 이 I/O가 발생하는 동안에는 Thread는 결과를 받기까지 대기 상태에 들어가게 된다.

현재 서버 시스템에서 대부분의 병목은 연산 시간보다 I/O Time이 너무 길고 자주 발생하기 때문에 발생한다. 즉, 이 병목을 해결하는 방법은 프로세스 혹은 쓰레드를 대기 상태로 두지 않고 계속 일을 시키는 방법인데 대표적으로 Node.js에 적용된 이벤트 루프와 고 언어의 고루틴이 있다. 근데 여기서 우리는 한 가지 궁금증이 생긴다. 아니 원래 쓰레드가 컨텍스트-스위칭 하면서 작업을 번갈아 가면서 하는건데 그게 병목이 걸리는 게 큰 문제인가? 사실 스레드는 상당히 비싼 자원이다.

> - Thread는 보통 256KB ~ 2MB 사이의 스택 크기를 가진다. 전통적인 서버 구성에서는 유저 당 쓰레드 하나에 할당하는게 일반적이었는데 Thread의 스택 사이즈를 1MB라고 한다면 4GB 메모리를 가진 서버에서는 4096개의 쓰레드만을 동시에 생성해서 사용할 수 있다.
> - 컨텍스트 스위칭이란 하나의 작업 상태를 저장하고 다른 작업으로 전환하여 수행하는 것을 말한다. 프로세스를 스위칭 할 때는 메모리 상태를 직접 PCB에 저장했어야 해서 비용이 굉장히 비싸므로 이를 해결하기 위해서 공유 메모리를 사용한다는 개념이었다. 그래서 쓰레드를 스위칭하는게 프로세스를 스위칭하는 것보다 저렴한 것은 사실이지만 쓰레드도 각종 레지스터 정보들은 전부 저장해야 한다.
> - 쓰레드를 생성하는 것도 비용이 많이 생성된다. 생성은 시스템 콜(System call)을 요구하는데 이 때 OS 레벨에서 컨텍스트 스위칭이 발생하고 OS로부터 사용 가능한 메모리 영역대를 할당 받게 되서 레이턴시가 높아 효율적이지 않다.

### 고루틴

> Goruntine은 Go runtime 환경에서 동작하는 쓰레드보다 굉장히 가벼운 실행 조각이다. 초기에 생성할 때 2KB의 매우 작은 스택 크기만을 필요로 하며 가지고 있는 레지스터도 프로그램 카운터 (PC)와 스택 포인터 (SP) 정도가 전부이다. 고루틴은 함수 단위로 실행할 수 있으며 함수 실행 앞에 go라는 키워드를 붙여서 생성한다.

```go
go func() {
  // Do some work.
}();
```

원래 Go runtime은 Go 1.14 이전 버전에는 C언어로 작성되어 있었다. Go 1.14 부터 runtime을 Go 언어로 작성하게 되면서 코어 코드 해석이 한결 편해졌다. 아래에는 고루틴의 구조체와 스케쥴러가 고루틴을 실행할 때 다루는 구조체인 gobuf가 정의되어 있다.

```go
type g struct {
  stack stack
  stackguard0 uintptr
  stackguard1 uintptr

  m *m // m (고루틴이 실행될 쓰레드)
  sched gobuf
  ...
}

type gobuf struct {
  sp uintptr // 스택 포인터
  pc uintptr // 프로그램 카운터
  g uintptr // 고루틴 포인터
  ctxt  unsafe.Pointer
  ret uintptr // 리턴 포인터
  lr uintptr // 리턴 레지스터 (고루틴 종료 후 돌아갈 장소)
  bp uintptr
}
```

### GMP Model과 Golang 동시성 모델

Golang의 동시성 모델의 기원은 1978년 Hoare가 저술한 "Communicating Sequential Process (이하 CSP)" 논문에 기바한다고 알려져 있다. CSP는 단순히 공유 메모리를 사용하지 않고 채널을 통해 데이터를 공유해서 뮤텍스, 세마포어를 사용하지 말자는 개념이다. 많은 병렬 프로그램이 공유 메모리로 인해 문제가 발생하기 때문에 이를 자제하자는 뜻인데 이런 모델은 Akka의 Actor Model과 많이 유사하다.

다음으로 고루틴에 대해 설명해보고자 한다. 고루틴은 실행흐름을 함수로 표현하는 논리적 단위인데 Go runtime에 생성된 고루틴의 스케쥴링을 담당한다. Go runtime의 코어 코드를 보면 친절하게 주석으로 런타임 환경의 개념어들이 정리되어 있다. Processor P는 논리적 프로세서를 의미하며 고 언어 코드를 실행하기 위한 정보를 가지고 있다. M은 실제 Worker Thread를 의미하며 M을 실행하려면 반드시 하나의 P와 연관되어야 한다. G는 고루틴을 의미한다. 여기서 P는 논리적인 프로세서를 의미한다. 아래 구조체 p가 가지고 있는 정보 중에는 GC가 발생할 때 쓰기 장벽을 지원하기 위한 변수와 고루틴 리스트를 가지고 있는 작업 큐를 가지고 있다. M의 경우에는 실제 OS 쓰레드와 관련된 변수가 많이 보인다.

```go
type p struct {
  id uint32
  ...
  runghead uint32
  rungtail uint32
  rung [256]guintptr // 로컬 고루틴 큐
  ...
  gcw gcWork
}
```

### 고루틴과 채널

> Go에서 동시에 처리해야 하는 작업은 고루틴으로 실행하고, 고루틴끼리 메시지를 주고받는 작업은 채널이라는 통로를 사용한다. 고루틴은 Go 프로그램 안에서 동시에 독립적으로 실행되는 흐름의 단위로, 스레드와 비슷한 개념이다. 하지만 스레드와 달리 고루틴은 수 킬로바이트 정도의 아주 적은 리소스에서 동작하므로 한 프로세스에 수천, 수만 개의 고루틴을 동작시킬 수 있다. 고루틴은 정보를 공유하는 방식이 아니라 서로 메시지를 주고 받는 방식으로 동작한다. 그래서 Lock으로 공유 메모리를 관리할 필요가 없고 구현도 어렵지 않다.
